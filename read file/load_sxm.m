%%%%%
% CODE DESCRIPTION : 
%     loadsxm reads in the topography scan file generated by the Nanonis
%     software. It parses the header and reads in the Binary data as well.
%     The return value is an array of struct of different channels.
%
% CODE HISTORY : 
%     mm/dd/yyyy
%     06/10/2013 HENRY YU CREATED
%     08/10/2013 Che-An Liu Add header.pathname
%     4/19/2018 Cheng-Li modified field name, delete factor
%%%%%
function data = load_sxm(filename, pathname, calibration)
header.filename = filename;
header.pathname = pathname;

if exist([pathname filename], 'file')
	fid = fopen([pathname filename], 'r', 'ieee-be');    % open with big-endian
else
	fprintf('File does not exist.\n');
	return;
end

s = fgetl(fid);
if ~strcmp(s, ':NANONIS_VERSION:')
	fprintf('File seems not to be a Nanonis file\n');
	return;
end
header.version = str2num(fgetl(fid));

% read header data
% The header consists of key-value pairs. Usually the key is on one line, embedded in colons 
% e.g. :SCAN_PIXELS:, the next line contains the value.
% Some special keys may have multi-line values (like :COMMENT:), in this case read value
% until next key is detected (line starts with a colon) and set read_tag to 0 (because key has
% been read already).

while 1
    s = strtrim(fgetl(fid));
    switch s
        % strings:
        case {':SCANIT_TYPE:', ':REC_DATE:', ':REC_TIME:', ':SCAN_FILE:', ':SCAN_DIR:'}
            header.(lower(s(2:end-1))) = strtrim(fgetl(fid));
        % comment:
        case ':COMMENT:'
            s_com = '';
            s2_location=ftell(fid);
            s2 = strtrim(fgetl(fid));
            while ~strncmp(s2, ':', 1)
                s_com = [s_com s2 char(13)];
                s2_location=ftell(fid);
                s2 = strtrim(fgetl(fid));
            end
            header.comment = s_com;
            fseek(fid,s2_location,'bof');
        % Z-controller settings:
        case ':Z-CONTROLLER:'
            header.z_ctrl_tags = strtrim(fgetl(fid));
            header.z_ctrl_values = strtrim(fgetl(fid));
        % numbers:
        case {':BIAS:', ':REC_TEMP:', ':ACQ_TIME:'}
            s2 = fgetl(fid);
            header.(lower(s(2:end-1))) = str2num(s2);
        case  ':SCAN_ANGLE:'
            s2 = fgetl(fid);
            header.angle = str2num(s2);
        % array of two numbers:
        case { ':SCAN_TIME:'}
            s2 = fgetl(fid);
            header.(lower(s(2:end-1))) = sscanf(s2, '%f');
              
        case ':SCAN_PIXELS:'
            s2 = fgetl(fid);
            pixels = sscanf(s2, '%f');
            header.icols = pixels(1);
            header.irows = pixels(2);
                      
        %scan range
        case ':SCAN_RANGE:'
            s2 = fgetl(fid);
            range = sscanf(s2, '%f');
            header.xrange = range(1);
            header.yrange = range(2);
            header.xyunit = 'm';
       
        %scan center and the boundaries of the scan.
        %note that this case typically comes up later than the 'SCAN_RANGE'
        %field
        case ':SCAN_OFFSET:'
            s2 = fgetl(fid);
            C = sscanf(s2, '%f');
            Xc = C(1); Yc = C(2);
            header.xcenter = Xc;
            header.ycenter = Yc;           
        % data info:
        case ':DATA_INFO:'
            s2 = strtrim(fgetl(fid));
            temp_count = 1;
            while length(s2)>2
                temp_s(temp_count, :) = strsplit(s2, '\t');
                s2 = strtrim(fgetl(fid));
                temp_count = temp_count + 1;
            end
            header.data_info = temp_s;
        case ':SCANIT_END:'
            break;
        otherwise % treat as strings
            s = regexprep(lower(s(2:end-1)), '[^a-z0-9_]', '_'); % replace anything except for a-z 0-9 with '_'
            s_location=ftell(fid);
            s_line = strtrim(fgetl(fid));
            s2 = '';
            while ~strncmp(s_line, ':', 1)
                s2 = [s2 s_line char(13)];
                s_location=ftell(fid);
                s_line = strtrim(fgetl(fid)); 
            end
            header.(s(1:min(end,30))) = s2;
            s = s_line;
            fseek(fid,s_location,'bof');  % already read next key (tag)
    end
end

% \1A\04 (hex) indicates beginning of binary data
s = [0 0];
while s~=[26 4]
	s2 = fread(fid, 1, 'char');
	s(1) = s(2);
	s(2) = s2;
end

%we now calculate the total number of images from the header.data_info
%field information
channels = {};
for i = 2:length(header.data_info(:,1))
    channel_name = header.data_info(i,2);
    if strcmp(header.data_info(i,4), 'both')
        image_numcount(i-1) = 2;
        channels = [channels, channel_name, strcat(channel_name, '_bwd')];
    else
        image_numcount(i-1) = 1;
        channels = [channels, channel_name];
    end
end

%We construct the most useful information/parameters (e.g. rx, ry, var.....)
image_num = sum(image_numcount);
dim = [header.icols, header.irows];
e = header.bias;
[rx,ry]=meshgrid(linspace(0,header.xrange,dim(1)), linspace(header.yrange,0,dim(2)));
[Rx_tmp, Ry_tmp] = meshgrid(linspace(-header.xrange/2 ,header.xrange/2, dim(1)), linspace(header.yrange/2, -header.yrange/2, dim(2)));
Rx=Rx_tmp*cosd(header.angle)+Ry_tmp*sind(header.angle)+header.xcenter;
Ry=-1*Rx_tmp*sind(header.angle)+Ry_tmp*cosd(header.angle)+header.ycenter;

%With all the parameters prepared, we can now collect them into one and
%also extract the map data from file as well
for i = 1:image_num
    temp_map = transpose(fread(fid, dim, 'float'));
    channel_name = channels{i};
    if strcmp(header.scan_dir, 'up')
        temp_map = flipud(temp_map);
    end
    
    if (length(channel_name)>3 && strcmp(channel_name(end-2:end), 'bwd'))
        temp_map = fliplr(temp_map);
    end
    
    data(i).type = '2D_map';
    switch channel_name
        case {'Z', 'Z_bwd'}
            data(i).map_unit = 'm';
        case {'Current', 'Current_bwd'}
            data(i).map_unit = 'A';
        otherwise
            data(i).map_unit = 'unit';
    end
    
    if ~isnan(calibration)
        data(i).map = temp_map*calibration*1e9;
        data(i).map_unit = 'nS';
    else
        data(i).map = temp_map;
    end
    data(i).channel = channel_name;
    data(i).name = LegalizeName(filename(1:end-4));
    data(i).e = e;
    data(i).rx = rx;
    data(i).ry = ry;
    data(i).Rx = Rx;
    data(i).Ry = Ry;
    data(i).info = header;
    %DataProInfo:
    data(i).DataProInfo{1}=0;
    data(i).DataProInfo{2}{1,1}='raw';data(i).DataProInfo{2}{1,3}='';
    data(i).DataProInfo{2}{1,2}=[data(i).name,'_',ChannelAbbr(data(i).channel)];
    data(i).DataProInfo{3}=[nanmean(temp_map(:)),nanstd(temp_map(:))];
    data(i).DataProInfo{4}=2;
    data(i).DataProInfo{5}(1,:)=[-4,4];
    data(i).DataProInfo{6}=[header.xcenter header.ycenter,header.xrange,header.yrange,...
        -header.angle,header.icols,header.irows];
    
    %replace nan with 0
    data(i).map(isnan(data(i).map))=0;
    
    
    
end
fclose(fid);
end






















